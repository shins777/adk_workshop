# Copyright 2025 Forusone(forusone777@gmail.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from google.adk import Runner
from google.genai import types
from collections.abc import AsyncGenerator
from google.adk.events import Event

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.utils import new_agent_text_message
from a2a.utils.errors import ServerError
from a2a.server.tasks import TaskUpdater

from a2a.types import (
    AgentCard,
    FilePart,
    FileWithBytes,
    FileWithUri,
    Part,
    TaskState,
    TextPart,
    UnsupportedOperationError,
)

from .convert import convert_a2a_parts_to_genai
from .convert import convert_genai_parts_to_a2a

class ADKAgentExecutor(AgentExecutor):
    """
    An agent executor that integrates a Google ADK agent with the A2A server framework.

    The ADKAgentExecutor manages the execution of a Google ADK agent, handling session management,
    message conversion between A2A and GenAI formats, and event queue updates. It processes user
    input, invokes the agent asynchronously, and updates the task state and artifacts in the event
    queue. The executor also provides a cancel method for unsupported operations.

    Methods:
        execute(context, event_queue): Processes the user query, runs the ADK agent, and updates the event queue.
        cancel(context, event_queue): Raises an error indicating that cancellation is not supported.
    """

    def __init__(self, runner: Runner, agent_card: AgentCard):

        self.runner = runner
        self.agent_card = agent_card

    def run_agent( self, 
                    session_id, 
                    user_id, 
                    new_message: types.Content) -> AsyncGenerator[Event]:

        """
        Runs the ADK agent asynchronously with the provided session and user information.

        This method invokes the agent's asynchronous run method, passing the session ID, user ID,
        and the new message content. It yields events generated by the agent during execution,
        which can include intermediate updates and the final response.

        Args:
            session_id (str): The session identifier for the conversation.
            user_id (str): The user identifier.
            new_message (types.Content): The user's message content to be processed by the agent.

        Yields:
            Event: Events generated by the agent during execution.
        """

        return self.runner.run_async(
            session_id=session_id, user_id=user_id, new_message=new_message
        )
    
    async def execute(self,
                      context: RequestContext,
                      event_queue: EventQueue,) -> None:
    
        """
        Executes the ADK agent in response to a user query and updates the event queue.

        This method processes the user input from the request context, manages the task state,
        builds the message for the agent, ensures the session exists, and asynchronously runs
        the agent. It updates the event queue with intermediate and final responses, including
        artifacts and status updates, to support both streaming and non-streaming workflows.

        Args:
            context (RequestContext): The request context containing user input and task information.
            event_queue (EventQueue): The event queue to which agent responses and status updates are published.

        Returns:
            None
        """

        print(f"### [ADKAgentExecutor|execute] Before invoking Agent context : {context}")
        print(f"### [ADKAgentExecutor|execute] Current task : {context.current_task}")
        print(f"### [ADKAgentExecutor|execute] Message : {context.message}")
        print(f"### [ADKAgentExecutor|execute] User's query : {context.get_user_input()}")
        print(f"### [ADKAgentExecutor|execute] Context ID : {context.message.contextId}")
        
        # Get session id from context. 
        session_id = context.message.contextId

        # Run the agent until either complete or the task is suspended.
        # https://google-a2a.github.io/A2A/sdk/python/#a2a.server.tasks.TaskUpdater
            # Helper class for agents to publish updates to a task's event queue.
            # Simplifies the process of creating and enqueueing standard task events.

        task_updater = TaskUpdater(event_queue, context.task_id, context.context_id)
        
        # Marks the task as submitted and publishes a status update.
        if not context.current_task:
            task_updater.submit()
        
        # Marks the task as working and publishes a status update.
        task_updater.start_work()

        # Message building.
        new_message = types.UserContent(
            parts=convert_a2a_parts_to_genai(context.message.parts),
        )

        # Get or create session from session_id(derived from context.message.contextId.)
        
        session = await self.runner.session_service.get_session(
            app_name=self.runner.app_name, user_id='self', session_id=session_id
        ) or await self.runner.session_service.create_session(
            app_name=self.runner.app_name, user_id='self', session_id=session_id
        )

        # Run Agent
        async for event in self.run_agent(session_id=session.id, 
                                         user_id=session.user_id, 
                                         new_message=new_message):
            
            if event.is_final_response():
                # Change content's part to fit to a2a part format. 
                parts = convert_genai_parts_to_a2a(event.content.parts)
                print('Yielding final response: %s', parts)
                task_updater.add_artifact(parts)
                task_updater.complete()

                break
            if not event.get_function_calls():
                print('Yielding update response')
                task_updater.update_status(
                    TaskState.working,
                    message=task_updater.new_agent_message(
                        convert_genai_parts_to_a2a(event.content.parts),
                    ),
                )
            else:
                print('Skipping event')

        print(f"### After invoking Agent")

    async def cancel(self, 
                     context: RequestContext, 
                     event_queue: EventQueue) -> None:
        
        raise ServerError(error=UnsupportedOperationError())

